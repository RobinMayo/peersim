EXERCICE I

Question 1 :

L'algorithme de verrouillage utilisÃ© dans la classe Application est un algorithme dÃ©rivÃ© de celui de Naimi-TreÌhel utilisant la notion de jeton.
Ainsi tout les sites se partagent le mÃªme jeton et seul le site possÃ©dant le jeton peut entrer en section critique. Dans la classe Application, les constantes initial_owner et nil servent Ã  discriminer le site possÃ©dant le jeton des autres.

Chaque processus connaÃ®t le processus suivant dans la file d'attente sauf quand il n'y a pas de suivant. La tÃªte est le processus qui possÃ¨de le jeton. La queue est le dernier processus qui a demandÃ© la file d'attente, (sauf s'il y a un seul processus dans cette file). Un chemin est organisÃ© de sorte que, quand un processus demande la section critique, sa demande est transmise Ã  la queue. Quand elle y arrive, il y a deux cas:

Variables de chaque noeud :
state : State
next : Queue<Long>
last : long
nb_cs : int = 0

function initialisation(Node host)
begin
	next = Queue<Long>()
	
end

function requestCS(Node host)
begin
	EDSimulator.add(State.requesting)
	
	IF (last not equal nil)
	begin
		SEND(host, dest, new Message(), protocol_id)
		last = nil
		return
	end
	executeCS(Node host)
end

function releaseCS(Node host)
begin
end

function receive_request(Node host, long from, long requester)
begin

end

function receive_token(Node host, long from,  Queue<Long> remote_queue, int counter)
begin

end


Question 2 :

Machine Ã  Ã©tat :


Question 3 :

ğ›‚ Ã©tant le temps moyen qu'un processus passe en section critique et ğ›ƒ le temps passÃ© entre les sections critique.

Le ratio ğ›’ = ğ›‚ / ğ›ƒ reprÃ©sente la charge du rÃ©seau.

Plus ce ratio est Ã©levÃ© plus le rÃ©seau est ralenti.