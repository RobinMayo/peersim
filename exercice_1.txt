EXERCICE I

Question 1 :

L'algorithme de verrouillage utilis√© dans la classe Application est un algorithme d√©riv√© de celui de Naimi-TreÃÅhel utilisant la notion de jeton.
Ainsi tout les sites se partagent le m√™me jeton et seul le site poss√©dant le jeton peut entrer en section critique. Dans la classe Application, les constantes initial_owner et nil servent √† discriminer le site poss√©dant le jeton des autres.

<WIKIPEDIA>
Chaque processus conna√Æt le processus suivant dans la file d'attente sauf quand il n'y a pas de suivant. La t√™te est le processus qui poss√®de le jeton. La queue est le dernier processus qui a demand√© la file d'attente, (sauf s'il y a un seul processus dans cette file). Un chemin est organis√© de sorte que, quand un processus demande la section critique, sa demande est transmise √† la queue. Quand elle y arrive, il y a deux cas:
- si le processus qui est √† la queue a le jeton et n'est pas en section critique, il envoie le jeton au demandeur, qui est alors autoris√© √† entrer en section critique.
- si le processus qui est √† la queue soit a le jeton et est en section critique soit l'attend, le demandeur devient le suivant de cette queue et devient la nouvelle queue.
</WIKIPEDIA>

Variables de chaque noeud :
√©tat : State
next : Queue<Long>
jeton : long // last
nb_cs : int = 0
global_counter : int = 0 // Compteur partag√©

function initialisation()
begin
	next = Queue<Long>()
	attendNouvelEv√®nementInterne(request_cs)
end

function attendNouvelEv√®nementInterne(√©v√®nement : Objet)
begin
	SI (√©v√®nement est un √©v√®nement)
	begin
		switch(√©v√®nement) {
		case release_cs:
			nb_cs++;
			releaseCS();
			break;
		case request_cs:
			requestCS();
			break;
		default:
			Exception("√âv√®nement de type inconnue")
	
	SINON SI (√©v√®nement est un message)
		SI (√©v√®nement == REQUEST_TAG)
		begin
			receive_request(√©v√®nement.queue, √©v√®nement.neudAppelant)
		SINON SI (√©v√®nement == TOKEN_TAG)
			receive_token(√©v√®nement.queue, √©v√®nement.conteur)
		end
	end
end

function requestCS(host : Node)
begin
	√©tat = State.requesting
	
	SI (jeton d√©j√† attribu√©)
	begin
		ENVOI(host, dest, nouveau Message(), protocol_id)
		jeton = nil
		return
	end
	
	// D√©but de la section critique :
	global_counter += 1
	√©tat = State.inCS
	wait(random)
	attendNouvelEv√®nementInterne(release_cs : √âv√®nementInterne)
end

function releaseCS()
begin
	√©tat = State.inCS
	wait(random)
	attendNouvelEv√®nementInterne(request_cs : √âv√®nementInterne)
	
	SI (next n'est pas vide)
	begin
		jeton = Premier√âl√©ment(next);
		ENVOI(host, dest = jeton, nouveau Token(), protocol_id)
		vider(next)
	end
end

function receive_request(from : long, requester : long)
begin
	SI (jeton pas attribu√©)
	begin
		SI (√©tat n'est pas State.tranquil)
		begin
			next.ajouteEnQueue(requester)
		SINON SI
		begin
			ENVOI(host, dest = requester, nouveau Token(), protocol_id)
			jeton = requester
		end
	SINON // Jamais atteint
		ENVOI(host, dest = jeton, nouveau Message(), protocol_id)
		jeton = requester
	end
end

function receive_token(remote_queue : Queue<Long>, counter : int)
begin
	// D√©but de la section critique :
	global_counter = counter
	remote_queue = ajouteEnQueue(next)
	next = remote_queue
	√©tat = State.inCS
end


Question 2 :

Machine √† √©tat :

state Application {
  inCS --> tranquil : InternalEvent(TypeEvent.release_cs, id_execution)
  tranquil --> requesting : last != nil
  requesting --> inCS : last == nil || receive_token()
}


Question 3 :

ùõÇ √©tant le temps moyen qu'un processus passe en section critique et ùõÉ le temps pass√© entre les sections critique.

Le ratio ùõí = ùõÇ / ùõÉ repr√©sente la charge du r√©seau.

Plus ce ratio est √©lev√© plus le r√©seau est ralenti.


Question 4 :



Question 5 :

Le fait que le temps de transmission moyen soit sup√©rieur au temps moyen pass√© en section critique ne change pas fondamentalement les r√©sultats, en effet le schedule_request ce fait avant la transition du jeton. Or tant que le jeton n'a pas √©t√© transmis, les autres processus ne peuvent pas s'ex√©cuter. Le temps pass√© en section critique et le temps de transmission s'additionne donc et rende le syst√®me plus lent.

Dans le d√©taille, on voit que les premiers instants du fonctionnement du syst√®me, le fait que le temps de transmission moyen soit sup√©rieur au temps moyen pass√© en section critique fait que le noeud ayant le jeton peut ex√©cuter plusieurs fois la section critique avant de recevoir une requ√™te et que la file des noeuds demandant l'acc√®s √† la section critique mettra plus de temps √† ce remplir. Cependant apr√®s que tout les noeuds aient ex√©cut√©s au moins une fois leurs section critique. Le temps pass√© en section critique et le temps de transmission du message s'additionnant rendront la suite de l'ex√©cution semblable √† ce qu'elle aurait √©t√© avec un temps de transmission moyen plus faible que le temps pass√© en section critique.
