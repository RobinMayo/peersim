EXERCICE II


Question 1 :

1. Si le noeud fautif est en section critique, il peut ne pas avoir le temps de transmettre le jeton et ainsi de désigner un nouveau noeud élue. Cela provoquerait le bloquage du système. 

2. Dans la classe Application, l'attribut next n'est modifié que dans les méthodes : initialisation, releaseCS, receive_request et receive_token. Les modifications dans initialisation et receive_request concerne l'initialisation du système dans la quelle la file est toujours vide. Ainsi, si le noeud fautif possède une file next non vide, il est forcément en section critique, dans ce cas cela provoque le bloquage du système comme expliqué dans la question 1.1.

En effet, à la réception d'un token, le noeud ajoute à sa liste personnel de noeuds en attente d'exécution, la liste transmise. En sachant que la liste personnelle du noeud est toujours vidé à la fin de la section critique dans la méthode releaseCS.

3. Si le noeud fautif possède une file next vide, n’est pointé par aucun last et aucun message à sa destination n’est en transit soit :
- Il a fait une demande de section critique est est dans la liste des noeuds en attentes du jeton. Dans ce cas le système finira par aboutir à un inter blocage.
- Il n'a pas fait de demande de section critique. Alors il disparaîtra du système impacter son exécution globale.


Question 2 :

random.seed 5
network.size 5
simulation.endtime 5000

protocol.reliableTransport UniformRandomTransport
protocol.reliableTransport.mindelay 5
protocol.reliableTransport.maxdelay 15

protocol.FIFOTransport projetara.util.FIFOTransport
protocol.FIFOTransport.transport reliableTransport

protocol.CheckpointerImpl projetara.checkpointing.algo1.CheckpointerImpl
protocol.CheckpointerImpl.transport FIFOTransport
protocol.CheckpointerImpl.checkpointable application
protocol.CheckpointerImpl.timecheckpointing 40

protocol.application projetara.application.ApplicationCheckpointable
protocol.application.timeCS 20
protocol.application.timeBetweenCS 10
protocol.application.transport CheckpointerImpl

control.crash projetara.checkpointing.CrashControler
control.crash.probacrash 1
control.crash.faulty_nodes 4
control.crash.checkpointer CheckpointerImpl
control.crash.at 3000

init.constantes Constantes
init.constantes.loglevel INFO


Question 3 :

La méthode createCheckpoint n'est pas appelée avec une période fixe et égale pour tout les noeuds afin de simuler un système réel dont les horloges internes des processus ne sont pas accessible et pas forcément synchronisés. On utilise donc un random afin de provoquer un checkpoint non coordonnée.
Un checkpoint synchronisé constituait un cas particulier exceptionnel dans un système réel.


Question 4 :

La méthode createCheckpoint provoque la sauvegarde des points de reprises. Dans cette méthode sont sauvegardés les données suivantes :
- La taille de la liste des états du système (variable state),
- La liste des noeuds en attente de section critique (variable next),
- Le pointeur vers le dernier noeud a avoir été en section critique (variable last),
- Le nombre de fois où le noeud courant s'est retrouvé en section critique (variable nb_cs),
- L'état du noeud (variable state),
- Le nombre total de sections critiques ayant eu lieu dans le système (variable global_counter),
- Les messages et token envoyés à chaque noeuds (variable saved_sent),
- Les messages et token reçus de chaque noeuds (variable saved_rcvd).

Un compteur d'état Si incrémenté à chaque sauvegarde
Pour chaque voisin Pj :
	un compteur d'émission SENTij et un compteur de réception RCVDji Chaque sauvegarde inclut Si, ainsi que SENTij et RCVDji pour chaque canal


Question 5 :

Une pile de table de hachage permettent de simuler la sauvegarde des données sur un support stable. En effet l'algorithme de Juang-Venkatesan enregistre le point de sauvegarde le plus recent dans la mémoire volatile alors que les points de sauvegardes les plus anciens sont copiés dans la mémoire persistante.
Une pile LIFO (Last-In-First-Out) émule bien ce procédé car le points de sauvegarde le plus récent est accessible rapidement alors que l'accès aux points de sauvegardes anciens implique de dépiler la pile ce qui prend (un peu) plus de temps comme un accès au disque prend plus de temps qu'un accès mémoire. 


Question 6 :

La classe CheckpointerImpl est un décorateur de protocole de transport car elle est utilisée pour envoyer ses propres messages entre les noeuds. La méthode send est donc redéfinie et permet ainsi de compter le nombre de messages entrants et sortants et sauvegarder les messages envoyés depuis le dernier checkpoint.


Question 7 :

Si les messages Wrapping n'étaient pas utilisés, on risquerait un inter bloquage pour cause de modification concurrente. En effet en l'absence de canal FIFO, les messages pourraient-être reçu dans le désordre par les différents noeuds. Ainsi un noeud pourrait recevoir plusieurs demandes de sections critique d'un même noeud.


Question 8 :

Lors de l'appel à la méthode recover de la classe CheckpointerImpl, on commence par stopper l'exécution du noeud courant puis on crée le point de sauvegarde (méthode recover). On commence alors la phase de recouvrement.

// WrappingMessages = messages orphelins.

Première phase, le recouvrement :
- Les messages rollback sont envoyés à tout les noeuds du système (méthode send_rollback_messages) afin de trouver un point de sauvegarde pour chaque noeud qui puisse former une ligne de recouvrement cohérente entre les différents noeuds.

- On compare pour cela le nombre de messages reçu par chaque noeud saved_rcvd avec le nombre de messages envoyés. En cas d'incohérences, le point de sauvegarde est détruit et on recommence la comparaison avec le point de sauvegarde antérieur (méthode receiveRollBackMessage). Après avoir trouvé un point de recouvrement cohérent, les noeuds avertissent leurs homologues via les messages FinishedRollback.

- On vérifie qu'on a bien reçu un message FinishedRollback de tout les autres noeuds du système (méthode receiveFinishedRollbackMessage).

Deuxième phase, du point de sauvegarde au crash :
	On cherche à present à retourner jusqu'à l'instant ou l'application a planté. Les noeuds savant qu'ils se sont envoyés des messages qui ont du être ignorés car postérieur au point de sauvegarde.

- Chaque noeud demande aux autres l'ensemble des messages qu'ils lui ont envoyés entre le point de sauvegarde et l'arrêt de l'exécution (méthode findMessagesToReplay).

- On retire de la liste des messages reçu, tout les messages qui n'ont pas encore été envoyé au point de sauvegarde que l'on souhaite restauré (méthode receiveAskMissingMessMessage).

receiveReplyAskMissingMessMessage :
- 

- Finalement, on restore l'état des noeuds avec les valeurs contenues dans les points de sauvegardes sélectionnés (méthode stop_recover).


Question 9 :

Une diffusion FIFO de messages m permet de s'assurer que tout processus diffusant m1 puis m2 provoquera la réception de m1 puis m2 par tout les processus corrects destinataires. En l'absence de canaux FIFO, un noeud ayant fini sa phase de rollBack enverrait des AskMissingMess qui pourraient-être reçu par des noeuds qui n'auraient pas fini leurs phase de rollBack. Ces noeuds enverraient donc des réponses sur le nombre de messages envoyés erroné. Cela provoquerait un RuntimeException("Error : inconcistency in cover line") dans la méthode receiveAskMissingMessMessage.
